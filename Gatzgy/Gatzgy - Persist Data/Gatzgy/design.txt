1)	First let me address my choices in terms of the user interface. My app uses two kinds of scenes: TableViews and Views. The Journal, Settings and Menu scenes are all types of TableViews and the Entry, Daily Challenge, and Add New Challenge scenes are all Views. My decisions for which to use was all based on what type of content I was going to displaying. In the Journal scene it was obvious that a table was necessary because of the sheer volume of entries that I would have to display. I thought table worked better than a page based version because a table would allow for quicker searching than multiple pages. The Settings and Menu scenes are both made of static tables, which I though worked best because they would be displaying multiple rows of date that would not ever be changing. The other scenes used Views instead of TableViews due to their irregular layouts. It would just be easier to start with nothing and build up than to start with a table and tear it apart. Also, these pages did not require the display of more than one data set, so a table view was unnecessary.

2)	Continuing with the UI. I implemented most of my buttons in the Navigation bar, to preserve screen space, as well as being visually appealing (Also the reason I when with the slide-out menu). I tried to use natural looking buttons whenever possible (i.e. the menu button, + button, the switch) in order to avoid using labeled buttons (like the Save and Done buttons) just to make the UI experience a bit more enjoyable and instinctive.

3)	In terms of displaying content. I chose to put title’s into TextFields because of their relative small size, but descriptions had to go into TextViews because of their much larger size.

4)	Now I’ll take you on a walkthrough of the overall design of my files and how I implemented most the logic. In all the files controlling a screen with a menu button, I’ve made sure to initialize the menu controller after the page loads. This was important because I wanted the user to have access to this feature as soon at the page loaded and without it, at least on most pages, the user would be pretty much trapped. Another common thing to do was load saved data. To do this I would often create a variable that was set to an empty array of the data type I was trying to load. Then I would call a load function to make grab old data. If the data existed, I would store it in the created variable and use that array to do whatever I need one the screen. If the data didn’t exist I would often call a function to load some sort of sample data, so that I would have something to work with.
5)	Almost all of my data was made through the process of defining a new class and setting up NSCoding so that way I could store the data on disk. I learned that this is very important for getting data to persist across sessions. I often created new classes because it is a convenient way to store multiple instance of variable that make up a single item (such as an entry being comprised of strings, and photos). This is much easier than storing everything in different types of array and then trying to recombine them later. However, I didn’t do this all the time. My other option for storing data was in the UserDefaults, which I learned is a convenient way to make small pieces of data persist (for example I used it to store the Challenge number which is a single Int). Storing in defaults lets you avoid going through the trouble of making a class, but it is a bit more limited than going through the whole NSCoding route.

6)	Getting the Daily Challenge to change daily was a fun task. At first I was experimenting with timers, but timers don’t continue to run while the app is not open, so that was going to work. Eventually I came up with the idea to just check the date every time the page was loaded and if the date was greater than the saved one, then it was time for a new challenge. This solution was surprisingly hard to come by and took several hours of research, but I eventually got it to work with a series of if statements. The date variable is called Fecha because I couldn’t call it date, due to a conflict of naming, so I went with Fecha which is the word for date in Spanish. I know that’s not conventional, but I figured it works just as well as date_.

7)	Another fun part of the Daily Challenge scene was getting it to remember the what the daily challenge was, which I did by creating a challenge number that was saved in UserDefaults. The challenge number is created randomly by the arc4random_uniform function. I set limits on what the random number can be by using the challenges.count method to make sure that all the challenges in the array could be selected and also stop the generated number from being too large.

8)	Another problem I solved was how to get the sample challenges to load. I really didn’t want to have to place a giant mass of code into every file that I might need to load the samples into, as this would greatly clutter the file. So instead I put all of the samples into their own file within a struct, this way they could be accessed by any file. But I still had a problem, if I just put the samples into the struct, then I’d have to deal with a for loop in the load sample function, so instead, I created an array of all the samples within the stuct so that I could just access the array from the load sample function. I found this to be a nice way to minimize the amount of time that I spent writing code.

9)	Another nice design choice is the use of the unwind function to transfer data from the new entry scene to the Journal scene. This reduces the redundancy of code because I don’t have to load the saved entries nor include the save entries functions. Also, all the work that would of gone in view did load is now taken out of the file, which just makes it so much cleaner.

10)	The last design choice that I want to talk about is in the SettingsViewController. I implanted that switch so that I change in its stat will save the position, on or off, to the UserDefaults. When the page reloads, it checks the value in UserDefaults and sets it to off if the value is 0. The page’s default state for the switch is on, so I didn’t need to worry about that. The switch is not exactly functional, as, due to time contraints, I was not able to implement the notification code. However, when I come back to the project, the I can incorporate this information into whether a notification gets sent.

11)	Overall, I realize that the aesthetics of Gatzgy are not the best, but this was my first time developing anything for iOS and I had to teach myself pretty much everything. It took much longer than expected to just get a firm grasp on the basics. Time permitting, I would have liked to implement a server to relieve some of the storage on disk and connect users, but, as a one-man project, the time was restraints were heavy.
